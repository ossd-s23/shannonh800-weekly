---
layout: post
title: Week 11 - Cathedral & The Bazaar
---

Hearing my classmates' updates on their group projects, as well as their perspectives on software development approaches, made me realize some of the differences, dynamics, and factors to consider in existing projects.

<!--more-->

### Group Project Reports
The key things I noticed when other groups were presenting were mainly 1) the methods of finding issues 2) the number of issues tackled and 3) communication with the communities.

1. In larger projects, members usually approached this process by going to the "Issues" tab within github and searching through the list for issues that were either most recently added, labelled as "good first issues," had the most discussion / comments, or labelled as "high priority." On the other hand, smaller groups tended to actually sit down with the groups and try to figure out high-level what the main issues to tackle are. For example, with the OpenLibrary group, they discussed what areas were the most needed for help and how to best help in the given state of the project. For my group (MAPLE), it's also on the smaller side and we also met with the team to discuss the general areas we can help with (front-end development), but the team tended to actually assign us issues directly themselves.

2. Along a similar note, for most of the larger projects, there are a lot of outstanding issues so it's much easier for those groups to tackle a larger frequency of issues, especially reporting or fixing bugs. Meanwhile, for smaller groups, it's usually more bespoke tasks, or building new features from scratch--like in my group--so it's a much smaller frequency, since it requires more alignment on exactly what the goals are and there are other moving parts to coordinate with. One interesting thing, though, is that for some of the largest projects actually have the opposite pattern--such as Linux--since the product itself is so complex that it takes a lot of reading and understanding to even start to look at the issues or tackle some of them.

3. Lastly, communication methods differ greatly amongst different projects. For larger groups, it seems that using discussions in the "Issues" tab and comments on pull / merge requests on github, or perhaps joining their Discord / Slack channels, gets the fastest response. Sitting in on the regular team meetings could be insightful as well. On the other hand, in smaller projects like mine, there are often separate meetings set up between the teams and the communities to work specifically on the tasks and areas we're helping with. In my group's case, we largely use email and slack for brief and responsive written communication and zoom for meetings.

### Cathedral & The Bazaar
I think what stood out to me the most during our class discussion were three lessons:

* "Good programmers know what to write. Great ones know what to rewrite (and reuse)." This one was interesting because although I understand and agree with it, it does seem perhaps counterintuitive at first. As someone mentioned, especially in educational settings, it's important to understand how things work to serve as a solid foundation for later learning, so sometimes that requires writing tedious things that might have better existing solutions out there. But at the same time, I can see why on the job, being able to take what already exists and tweak it to work for your task is a more important skill--after all, why waste time trying to fix what's not broken? Also, it's kind of an arrogant attitude to hold that you should always write things from scratch yourself, as that's essentially implying your code will be better / more efficient than anyone else's.

* "Plan to throw one away; you will, anyhow." This one mainly stood out to me because while conceptually it makes sense, it's just hard to implement in reality--like the sunk cost fallacy. What Professor Klukowska shared in class about how a lot of students in Algorithmic Problem Solving will keep trying to make their original approach work for a problem, even though it's not a workable solution, really demonstrates it. And I find myself often relating to this, despite realizing it's necessary to move on and try something new sometimes.

* "When you lose interest in a program, your last duty to it is to hand it off to a competent successor." Out of all the lessons, this was the most directly applicable to the concept of open source projects. It's interesting that usually when you start a project, you think you're the only stakeholder involved--or at least, the most important one. But in reality, if you're building a project with many users and contributors, you have a sort of responsibility to allow them to continue using the product they love or building the project they've invested time and effort into. And at the end of the day, it's also a bit of a duty to your past self, by making sure your own time and efforts at the start weren't in vain, since there's at least someone else who can help carry it forward.